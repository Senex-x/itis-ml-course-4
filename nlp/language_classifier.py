# from pprint import pprint as print
# from gensim.models.fasttext import FastText
# from gensim.test.utils import datapath
import logging
import re


def get_wide_ordinal(char):
    if len(char) != 2:
        return ord(char)
    return 0x10000 + (ord(char[0]) - 0xD800) * 0x400 + (ord(char[1]) - 0xDC00)


def filter_text(text):
    filtered_text = []
    for letter in text:
        if letter == ' ' or letter in tatar_alphabet or letter in russian_alphabet:
            filtered_text.append(letter)
    return re.sub(' +', ' ', ''.join(filtered_text))


def filter_unique_only(source, other):
    unique_characters = []
    for letter in source:
        if letter not in other:
            unique_characters.append(letter)
    return unique_characters


message = '–ê—Ñ–∏—à–∞ –î–æ–º–∞ —Ç–∞—Ç–∞—Ä—Å–∫–æ–π –∫–Ω–∏–≥–∏ –Ω–∞ —ç—Ç—É –Ω–µ–¥–µ–ª—é / –¢–∞—Ç–∞—Ä –∫–∏—Ç–∞–±—ã –π–æ—Ä—Ç—ã–Ω–¥–∞ –±—É –∞—Ç–Ω–∞–¥–∞ –Ω–∏–ª”ô—Ä –∫”©—Ç–µ–ª”ô üí•  ‚ñ™Ô∏è' \
          '5 —Å–µ–Ω—Ç—è–±—Ä—å, 15:00. –ö–ê–õ–õ–ò–ì–†–ê–§–ò–Ø –¢—ã–ª—Å—ã–º–ª—ã –≥–∞—Ä”ô–ø —Ö”ô—Ä–µ—Ñ–ª”ô—Ä–µ –±–µ–ª”ô–Ω –¥—É—Å–ª–∞—à—É –º”©–º–∫–∏–Ω–ª–µ–≥–µ. ' \
          '‚è∫–í–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å –ø–æ–¥—Ä—É–∂–∏—Ç—å—Å—è —Å –≤–æ–ª—à–µ–±–Ω–æ–π –∞—Ä–∞–±—Å–∫–æ–π –≤—è–∑—å—é.   ' \
          '‚ñ™Ô∏è6 —Å–µ–Ω—Ç—è–±—Ä—å 14:00. ”ò–î”ò–ë–ò –û–°–¢–ê–•–ê–ù”ò ¬´–Ø“£–∞ –∏—Å–µ–º¬ª –ª–∞–±–æ—Ä–∞—Ç–æ—Ä–∏—è—Å–µ–Ω–¥”ô –õ–∏–ª–∏—è –ì—ã–π–±–∞–¥—É–ª–ª–∏–Ω–∞–¥–∞–Ω —à–∏–≥—ä—Ä–∏—è—Ç –¥”ô—Ä–µ—Å–µ ' \
          '‚è∫–ú–∞—Å—Ç–µ—Ä-–∫–ª–∞—Å—Å –ø–æ –ø–æ—ç–∑–∏–∏ –æ—Ç –õ–∏–ª–∏–∏ –ì–∏–±–∞–¥—É–ª–ª–∏–Ω–æ–π. –í —Ä–∞–º–∫–∞—Ö –ª–∞–±–æ—Ä–∞—Ç–æ—Ä–∏–∏ ¬´–Ø–Ω–∞ –∏—Å–µ–º¬ª  ' \
          '‚ñ™Ô∏è6 —Å–µ–Ω—Ç—è–±—Ä—å, 16:00. BEATMAKING. ABLETON LIVE 11 –ë–µ—Ä–≥”ô–ª”ô–ø Ableton Live –∫—É—à—ã–º—Ç–∞—Å—ã–Ω–¥–∞ –º—É–∑—ã–∫–∞ –∏“ó–∞—Ç –∏—Ç“Ø –Ω–∏–≥–µ–∑–ª”ô—Ä–µ–Ω ”©–π—Ä”ô–Ω”ô–±–µ–∑. ' \
          '‚è∫–í–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å –Ω–∞—É—á–∏—Ç—å—Å—è —Ç–≤–æ—Ä—á–µ—Å—Ç–≤—É –≤ –ø—Ä–æ–≥—Ä–∞–º–º–µ Ableton Live. ' \
          ' ‚ñ™Ô∏è6 —Å–µ–Ω—Ç—è–±—Ä—å, 18:00. –ß–ï–†–î–ê–ß–ù–´–ï –ò–°–¢–û–†–ò–ò –¢–∞—Ç–∞—Ä–ª–∞—Ä–¥–∞ –±—É–ª–≥–∞–Ω —Ö–æ—Ä–∞—Ñ–∞—Ç–ª–∞—Ä “ª”ô–º —ã—à–∞–Ω—É–ª–∞—Ä —Ç—É—Ä—ã–Ω–¥–∞ –∫–≤–µ—Å—Ç —É–∑—ã–ø, –ô–æ—Ä—Ç–Ω—ã“£ —á–æ—Ä–º–∞—Å—ã–Ω–¥–∞ —Å–∞–∫–ª–∞–Ω–≥–∞–Ω —Å–µ—Ä–ª”ô—Ä–Ω–µ —á–∏—à”ô –∞–ª—ã—Ä—Å—ã–∑. ' \
          '‚è∫–í–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å —É–∑–Ω–∞—Ç—å –æ –ø–æ–≤–µ—Ä—å—è—Ö –∏ —Å—É–µ–≤–µ—Ä–∏—è—Ö —Ç–∞—Ç–∞—Ä, –ø—Ä–æ–π—Ç–∏ –∫–≤–µ—Å—Ç –∏ –∑–∞–≥–ª—è–Ω—É—Ç—å –≤ —á–µ—Ä–¥–∞–∫ –î–æ–º–∞ —Ç–∞—Ç–∞—Ä—Å–∫–æ–π –∫–Ω–∏–≥–∏.  ' \
          '‚ñ™Ô∏è7 —Å–µ–Ω—Ç—è–±—Ä—å, 15:00. –ß”ò–ô –¢–∞—Ç–∞—Ä ”ô–¥”ô–±–µ–Ω”ô —Ç—É—Ä—ã –∫–∏—Ç–µ—Ä–µ–ø —á”ô–π —ç—á”ô—Ä–≥”ô ”©–π—Ä”ô–Ω”ô–±–µ–∑. ‚è∫–£—á–∏–º—Å—è —á–∞–µ–ø–∏—Ç–∏—é —Å–æ–≥–ª–∞—Å–Ω–æ —Ç–∞—Ç–∞—Ä—Å–∫–æ–º—É —ç—Ç–∏–∫–µ—Ç—É.  ' \
          '‚ñ™Ô∏è8 —Å–µ–Ω—Ç—è–±—Ä—å, 18:00. –°–û–ë–†–ê–ù–ò–ï –ö–ù–ò–ñ–ù–û–ì–û –ö–õ–£–ë–ê –õ–û–ì–û–° –ö–ª—É–±–Ω—ã“£ —Ç—É–≥–∞–Ω –∫”©–Ω–µ! ‚è∫–ù–∞ —Ç—Ä–∞–¥–∏—Ü–∏–æ–Ω–Ω–æ–º ¬´–∫–Ω–∏–∂–Ω–æ–º —Å–æ–±—Ä–∞–Ω–∏–∏¬ª –æ—Ç–º–µ—Ç—è—Ç –î–µ–Ω—å —Ä–æ–∂–¥–µ–Ω–∏–µ –∫–ª—É–±–∞!  ' \
          '‚ñ™Ô∏è8 —Å–µ–Ω—Ç—è–±—Ä—å 16:00. BEATMAKING. ABLETON LIVE 11 –ë–µ—Ä–≥”ô–ª”ô–ø Ableton Live –∫—É—à—ã–º—Ç–∞—Å—ã–Ω–¥–∞ –º—É–∑—ã–∫–∞ –∏“ó–∞—Ç –∏—Ç“Ø –Ω–∏–≥–µ–∑–ª”ô—Ä–µ–Ω ”©–π—Ä”ô–Ω”ô–±–µ–∑. ' \
          '‚è∫–í–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å –Ω–∞—É—á–∏—Ç—å—Å—è —Ç–≤–æ—Ä—á–µ—Å—Ç–≤—É –≤ –ø—Ä–æ–≥—Ä–∞–º–º–µ Ableton Live.  ' \
          '‚ñ™Ô∏è8 —Å–µ–Ω—Ç—è–±—Ä—å, 17:30. –ß–ï–†–î–ê–ß–ù–´–ï –ò–°–¢–û–†–ò–ò –¢–∞—Ç–∞—Ä–ª–∞—Ä–¥–∞ –±—É–ª–≥–∞–Ω —Ö–æ—Ä–∞—Ñ–∞—Ç–ª–∞—Ä “ª”ô–º —ã—à–∞–Ω—É–ª–∞—Ä —Ç—É—Ä—ã–Ω–¥–∞ –∫–≤–µ—Å—Ç —É–∑—ã–ø, –ô–æ—Ä—Ç–Ω—ã“£ —á–æ—Ä–º–∞—Å—ã–Ω–¥–∞ —Å–∞–∫–ª–∞–Ω–≥–∞–Ω —Å–µ—Ä–ª”ô—Ä–Ω–µ —á–∏—à”ô –∞–ª—ã—Ä—Å—ã–∑. ' \
          '‚è∫–í–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å —É–∑–Ω–∞—Ç—å –æ –ø–æ–≤–µ—Ä—å—è—Ö –∏ —Å—É–µ–≤–µ—Ä–∏—è—Ö —Ç–∞—Ç–∞—Ä, –ø—Ä–æ–π—Ç–∏ –∫–≤–µ—Å—Ç –∏ –∑–∞–≥–ª—è–Ω—É—Ç—å –≤ —á–µ—Ä–¥–∞–∫ –î–æ–º–∞ —Ç–∞—Ç–∞—Ä—Å–∫–æ–π –∫–Ω–∏–≥–∏.  ' \
          '‚ñ™Ô∏è9 —Å–µ–Ω—Ç—è–±—Ä—å, 18:00. ¬´–¢–´–õ–°–´–ú–õ–´ –£–ö–£¬ª “∫–∞—Ä—Ä–∏ –ü–æ—Ç—Ç–µ—Ä–Ω—ã —Ç–∞—Ç–∞—Ä—á–∞ –¥–∞ —É–∫—ã–ø –±—É–ª–≥–∞–Ω—ã–Ω –±–µ–ª”ô—Å–µ–∑–¥–µ—Ä –∏–Ω–¥–µ. ”ò–º–º–∞ –∞–Ω—ã –±–µ—Ä–≥”ô–ª”ô–ø —É–∫—É —Ç–∞–≥—ã–Ω –¥–∞ –∫“Ø“£–µ–ª–ª–µ—Ä”ô–∫ “ª”ô–º‚Ä¶ —Ç—ã–ª—Å—ã–º–ª—ã—Ä–∞–∫! ”ò –∞–Ω–Ω–∞—Ä—ã –∫–≤–∏–∑ “Ø—Ç”ô—Ä–±–µ–∑! ' \
          '‚è∫ –ß–∏—Ç–∞–µ–º –ì–∞—Ä—Ä–∏ –ü–æ—Ç—Ç–µ—Ä–∞ –Ω–∞ —Ç–∞—Ç–∞—Ä—Å–∫–æ–º –≤–º–µ—Å—Ç–µ!  ‚ñ™Ô∏è10 —Å–µ–Ω—Ç—è–±—Ä—å, 13:00. –≠–ö–°–ö–£–†–°–ò–Ø –¢–∞—Ç–∞—Ä–ª–∞—Ä–¥–∞ –∫–∏—Ç–∞–ø—á—ã–ª—ã–∫ —Ç–∞—Ä–∏—Ö—ã —Ç—É—Ä—ã–Ω–¥–∞ –±–µ–ª”ô—Å–µ–≥–µ–∑ –∫–∏–ª—Å”ô, —Ä”ô—Ö–∏–º –∏—Ç–µ–≥–µ–∑ ' \
          '‚è∫ –û–±–∑–æ—Ä–Ω–∞—è —ç–∫—Å–∫—É—Ä—Å–∏—è ¬´–ò—Å—Ç–æ—Ä–∏—è –∫–Ω–∏–≥–∏ –æ—Ç –ø–µ—Ä–≥–∞–º–µ–Ω—Ç–∞ –¥–æ —Ü–∏—Ñ—Ä—ã¬ª  üìç–ö–∞–∑–∞–Ω—å, —É–ª. –û—Å—Ç—Ä–æ–≤—Å–∫–æ–≥–æ, –¥. 15 ‚òéÔ∏è (843) 590-80-66,  (843) 590-80-67'

tatar_alphabet = '–ê –∞ ”ò ”ô –ë –± –í –≤ –ì –≥ –î –¥ –ï –µ –Å —ë –ñ –∂ “ñ “ó –ó –∑ –ò –∏ –ô –π –ö –∫ –õ –ª –ú –º –ù –Ω “¢ “£ –û –æ ”® ”© –ü –ø –† —Ä –° —Å –¢ —Ç –£ —É “Æ “Ø –§ —Ñ –• —Ö “∫ “ª –¶ —Ü –ß —á –® —à –© —â –™ —ä –´ —ã –¨ —å –≠ —ç –Æ —é –Ø —è'.split()

russian_alphabet = '–ê –∞ –ë –± –í –≤ –ì –≥ –î –¥ –ï –µ –Å —ë –ñ –∂ –ó –∑ –ò –∏ –ô –π –ö –∫ –õ –ª –ú –º –ù –Ω –û –æ –ü –ø –† —Ä –° —Å –¢ —Ç –£ —É –§ —Ñ –• —Ö –¶ —Ü –ß —á –® —à –© —â –™ —ä –´ —ã –¨ —å –≠ —ç –Æ —é –Ø —è'.split()

unique_tatar_alphabet = ['”ò', '”ô', '“ñ', '“ó', '“¢', '“£', '”®', '”©', '“Æ', '“Ø', '“∫', '“ª']

import re
import codecs

# import fasttext
#
# PRETRAINED_MODEL_PATH = '/tmp/lid.176.bin'
# model = fasttext.load_model(PRETRAINED_MODEL_PATH)

import csv

COLUMNS = [
    "msg_id",
    "date",
    "msg_content",
]

COLUMNS2 = [
    "date",
    "msg_content",
]

tatar_file = codecs.open('tatar_messages.csv', 'w', "utf_8_sig")
uncertain_file = codecs.open('uncertain_messages.csv', 'w', "utf_8_sig")
certain_file = codecs.open('certain.csv', 'w', "utf_8_sig")

csv_writer = csv.DictWriter(tatar_file, COLUMNS, dialect="unix", quoting=csv.QUOTE_NONNUMERIC)
csv_writer.writeheader()

csv_writer_uncertain = csv.DictWriter(uncertain_file, COLUMNS, dialect="unix", quoting=csv.QUOTE_NONNUMERIC)
csv_writer_uncertain.writeheader()

csv_writer_certain = csv.DictWriter(certain_file, COLUMNS2, dialect="unix", quoting=csv.QUOTE_NONNUMERIC)

csv_writer_leftover = csv.DictWriter(codecs.open('tatar_leftover_messages.csv', 'w', "utf_8_sig"), COLUMNS, dialect="unix", quoting=csv.QUOTE_NONNUMERIC)

with open('original_messages.csv', encoding="utf-8-sig", ) as csv_file:
    csv_reader = csv.reader(csv_file, delimiter=',')
    line_count = 0
    for row in csv_reader:
        id = row[0]
        date = row[1]
        message = row[2]

        classified = False

        for tatar_letter in unique_tatar_alphabet:
            if tatar_letter in message:
                csv_writer.writerow({
                    "msg_id": id,
                    "date": date,
                    "msg_content": message,
                })
                classified = True
                break

        if not classified:
            csv_writer_uncertain.writerow({
                "msg_id": id,
                "date": date,
                "msg_content": message,
            })


trigger_ru_words = '–¥–æ–º—Ç–∞—Ç–∞—Ä—Å–∫–æ–π–∫–Ω–∏–≥–∏ –º—É–∑–µ–π–æ–Ω–ª–∞–π–Ω –ê—Ñ–∏—à–∞ –ø—Ä–∏–≥–ª–∞—à–∞–µ–º –°–ø–∏–∫–µ—Ä: –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è'.split()

import re

with open('tatar_messages.csv', encoding="utf-8-sig", ) as csv_file:
    csv_reader = csv.reader(csv_file, delimiter=',')
    line_count = 0
    for row in csv_reader:
        id = row[0]
        date = row[1]
        message = row[2]

        classified = False

        for word in trigger_ru_words:
            if re.search(word, message, re.IGNORECASE):
                csv_writer_certain.writerow({
                    "date": date,
                    "msg_content": message,
                })
                classified = True
                break

        if not classified:
            csv_writer_leftover.writerow({
                "msg_id": id,
                "date": date,
                "msg_content": message,
            })

# import polyglot
# from polyglot.text import Text, Word
# text = Text("Bonjour, Mesdames.")
# text.language

# DOESN'T WORK
# from langdetect import detect_langs, DetectorFactory
# DetectorFactory.seed = 0
# print(detect_langs('–¢–∞—Ç–∞—Ä –∫–∏—Ç–∞–±—ã –π–æ—Ä—Ç—ã–Ω–¥–∞ –±—É –∞—Ç–Ω–∞–¥–∞ –Ω–∏–ª”ô—Ä –∫”©—Ç–µ–ª”ô'))


# import cld3
# cld3.get_language("ÂΩ±ÈüøÂåÖÂê´Â∞çÊ∞£ÂÄôÁöÑËÆäÂåñ‰ª•ÂèäËá™ÁÑ∂Ë≥áÊ∫êÁöÑÊûØÁ´≠Á®ãÂ∫¶")
# LanguagePrediction(language='zh', probability=0.999969482421875, is_reliable=True, proportion=1.0)


# fileObj = codecs.open("text.txt", "r", "utf_8_sig")
# text = fileObj.read()  # –∏–ª–∏ —á–∏—Ç–∞–π—Ç–µ –ø–æ —Å—Ç—Ä–æ–∫–µ
# text = re.sub('0...', '', text)
# text = text.replace("\n", " ").replace("\r", "").replace("  ", " ")
# print(len(text))
# print(text)
# fileObj.close()
#
# codecs.open('out.txt', 'w', "utf_8_sig").write(text)


# print('tat')
# for letter in tatar_alphabet:
#     print(get_wide_ordinal(letter[0]))
# print('ru')
# for letter in russian_alphabet:
#     print(get_wide_ordinal(letter[0]))
